# Copyright Â© Aptos Foundation
# SPDX-License-Identifier: Apache-2.0

"""
Wrapper utilities for integrating with the official Aptos CLI.

This module provides Python interfaces to the Aptos command-line interface (CLI),
enabling seamless integration between Python applications and the official Aptos
tooling. It supports Move package compilation, testing, and local testnet management.

Key Features:
- **Move Compilation**: Compile Move packages with named address resolution
- **Package Testing**: Run Move unit tests with proper environment setup
- **Local Testnet**: Start and manage local Aptos testnets for development
- **CLI Integration**: Automatic detection and execution of Aptos CLI commands
- **Error Handling**: Comprehensive error reporting for CLI operations
- **Process Management**: Robust subprocess management with output capture

Supported Operations:
- Move package compilation with metadata generation
- Move unit test execution with coverage reporting
- Local testnet startup with faucet integration
- Named address parameter resolution
- CLI availability detection and validation

Use Cases:
- Development workflow automation
- CI/CD pipeline integration
- Local testing environment setup
- Move package build systems
- Automated deployment scripts
- Developer tooling and IDE integration

Examples:
    Compile a Move package::

        from aptos_sdk.aptos_cli_wrapper import AptosCLIWrapper
        from aptos_sdk.account_address import AccountAddress

        # Define named addresses
        named_addresses = {
            "MyModule": AccountAddress.from_str("***1234..."),
            "Treasury": AccountAddress.from_str("***5678...")
        }

        # Compile the package
        AptosCLIWrapper.compile_package(
            package_dir="./my-move-package",
            named_addresses=named_addresses
        )

    Run Move unit tests::

        # Test the package with same named addresses
        AptosCLIWrapper.test_package(
            package_dir="./my-move-package",
            named_addresses=named_addresses
        )

    Start a local testnet::

        # Start local node with faucet
        local_node = AptosCLIWrapper.start_node()

        # Wait for node to become operational
        is_ready = await local_node.wait_until_operational()

        if is_ready:
            print("Local testnet is ready!")
            # Use LOCAL_NODE and LOCAL_FAUCET constants for connections

        # Clean up when done
        local_node.stop()

    Check CLI availability::

        if AptosCLIWrapper.does_cli_exist():
            print("Aptos CLI is available")
        else:
            print("Please install the Aptos CLI")

Environment Variables:
    APTOS_CLI_PATH: Path to the Aptos CLI executable if not in system PATH.

Requirements:
    - Aptos CLI installed and accessible
    - Rust toolchain (for Move compilation)
    - Network access (for dependency resolution)
    - Sufficient disk space for compilation artifacts

Error Handling:
    The module provides specific exception types:
    - MissingCLIError: CLI not found or not accessible
    - CLIError: CLI command execution failed

Security Considerations:
    - Local testnets are for development only
    - Private keys generated by local testnets are not secure
    - Compilation artifacts may contain sensitive information
    - Subprocess execution should be used carefully in production

Note:
    This wrapper requires the official Aptos CLI to be installed. The local
    testnet functionality creates temporary directories and processes that
    should be properly cleaned up after use.
"""

from __future__ import annotations

import asyncio
import os
import shutil
import subprocess
import tempfile
import threading
import time
from typing import Dict, List

from .account_address import AccountAddress
from .async_client import FaucetClient, RestClient

# Default CLI binary path - can be overridden via environment variable
DEFAULT_BINARY = os.getenv("APTOS_CLI_PATH", "aptos")

# Local testnet endpoint URLs
LOCAL_FAUCET = "http://127.0.0.1:8081"  # Default local faucet endpoint
LOCAL_NODE = "http://127.0.0.1:8080/v1"  # Default local node REST API endpoint

# Maximum time to wait for local testnet to become operational
MAXIMUM_WAIT_TIME_SEC = 30


class AptosCLIWrapper:
    """Python wrapper for the official Aptos CLI with integrated tooling support.

    This class provides static methods for invoking Aptos CLI operations from Python,
    including Move package compilation, testing, and local testnet management. It
    handles subprocess management, error reporting, and named address resolution.

    Key Features:
    - **Static Interface**: All methods are static for easy access
    - **Error Handling**: Comprehensive error reporting with detailed output
    - **Named Addresses**: Automatic formatting of named address parameters
    - **Process Management**: Robust subprocess execution with output capture
    - **Validation**: CLI availability checking before execution

    Examples:
        Basic package operations::

            from aptos_sdk.aptos_cli_wrapper import AptosCLIWrapper

            # Check if CLI is available
            if not AptosCLIWrapper.does_cli_exist():
                raise Exception("Aptos CLI not found")

            # Compile a Move package
            AptosCLIWrapper.compile_package("./my-package", {})

            # Run tests
            AptosCLIWrapper.test_package("./my-package", {})

        With named addresses::

            from aptos_sdk.account_address import AccountAddress

            named_addresses = {
                "admin": AccountAddress.from_str("***1"),
                "user": AccountAddress.from_str("***2")
            }

            AptosCLIWrapper.compile_package(
                package_dir="./complex-package",
                named_addresses=named_addresses
            )

    Note:
        All methods require the Aptos CLI to be installed and accessible.
        Use does_cli_exist() to verify availability before calling other methods.
    """

    @staticmethod
    def prepare_named_addresses(
        named_addresses: Dict[str, AccountAddress]
    ) -> List[str]:
        """Convert named addresses dictionary to CLI argument format.

        This method transforms a Python dictionary of named addresses into the
        command-line argument format expected by the Aptos CLI. It handles the
        proper formatting and comma separation required by the CLI.

        Args:
            named_addresses: Dictionary mapping address names to AccountAddress objects.

        Returns:
            List of CLI arguments for named addresses, empty if no addresses provided.

        Examples:
            Empty addresses::

                >>> AptosCLIWrapper.prepare_named_addresses({})
                []

            Single address::

                >>> addresses = {"admin": AccountAddress.from_str("***1")}
                >>> AptosCLIWrapper.prepare_named_addresses(addresses)
                ['--named-addresses', 'admin=***1']

            Multiple addresses::

                >>> addresses = {
                ...     "admin": AccountAddress.from_str("***1"),
                ...     "user": AccountAddress.from_str("***2")
                ... }
                >>> args = AptosCLIWrapper.prepare_named_addresses(addresses)
                >>> args
                ['--named-addresses', 'admin=***1,user=***2']

        Note:
            The CLI expects named addresses in a comma-separated format after
            the --named-addresses flag. This method handles the formatting
            automatically.
        """
        total_names = len(named_addresses)
        args: List[str] = []
        if total_names == 0:
            return args

        args.append("--named-addresses")
        for idx, (name, addr) in enumerate(named_addresses.items()):
            to_append = f"{name}={addr}"
            if idx < total_names - 1:
                to_append += ","
            args.append(to_append)
        return args

    @staticmethod
    def compile_package(package_dir: str, named_addresses: Dict[str, AccountAddress]):
        """Compile a Move package using the Aptos CLI.

        This method compiles a Move package with the specified named addresses,
        generating bytecode and metadata required for package publishing. The
        compilation process validates Move code, resolves dependencies, and
        produces deployable artifacts.

        Args:
            package_dir: Path to the directory containing the Move package
                (must contain a Move.toml file).
            named_addresses: Dictionary mapping named address identifiers
                to their resolved AccountAddress values.

        Raises:
            MissingCLIError: If the Aptos CLI is not found or accessible.
            CLIError: If the compilation process fails with detailed error output.

        Examples:
            Compile basic package::

                AptosCLIWrapper.compile_package(
                    package_dir="./my-move-package",
                    named_addresses={}
                )

            Compile with named addresses::

                from aptos_sdk.account_address import AccountAddress

                named_addresses = {
                    "deployer": AccountAddress.from_str("***1234..."),
                    "resource_account": AccountAddress.from_str("***5678...")
                }

                AptosCLIWrapper.compile_package(
                    package_dir="./complex-package",
                    named_addresses=named_addresses
                )

        Compilation Output:
            - Generated bytecode in build/ directory
            - Package metadata for publishing
            - Dependency resolution artifacts
            - ABI files for integration

        Note:
            - Requires Move.toml configuration file in package directory
            - Named addresses must match those declared in Move.toml
            - Compilation artifacts are saved to build/ subdirectory
            - The --save-metadata flag ensures metadata is generated for publishing
        """
        AptosCLIWrapper.assert_cli_exists()
        args = [
            DEFAULT_BINARY,
            "move",
            "compile",
            "--save-metadata",
            "--package-dir",
            package_dir,
        ]
        args.extend(AptosCLIWrapper.prepare_named_addresses(named_addresses))

        process_output = subprocess.run(args, capture_output=True)
        if process_output.returncode != 0:
            raise CLIError(args, process_output.stdout, process_output.stderr)

    @staticmethod
    def start_node() -> AptosInstance:
        """Start a local Aptos testnet for development and testing.

        This method launches a complete local Aptos testnet including:
        - A single validator node
        - Built-in faucet service
        - REST API endpoint
        - Pre-funded test accounts

        Returns:
            AptosInstance object representing the running testnet.

        Raises:
            MissingCLIError: If the Aptos CLI is not found or accessible.

        Examples:
            Basic local testnet::

                # Start the testnet
                testnet = AptosCLIWrapper.start_node()

                # Wait for it to become operational
                is_ready = await testnet.wait_until_operational()

                if is_ready:
                    # Use LOCAL_NODE and LOCAL_FAUCET for connections
                    from aptos_sdk.async_client import RestClient, FaucetClient

                    client = RestClient(LOCAL_NODE)
                    faucet = FaucetClient(LOCAL_FAUCET, client)

                    # Perform operations...

                # Clean up
                testnet.stop()

            Context manager pattern::

                async def with_testnet():
                    testnet = AptosCLIWrapper.start_node()
                    try:
                        await testnet.wait_until_operational()
                        yield testnet
                    finally:
                        testnet.stop()

        Testnet Features:
            - Fresh blockchain state for each run
            - Pre-funded accounts for testing
            - Fast block times for rapid iteration
            - Full Move VM and transaction processing
            - REST API compatible with mainnet/testnet

        Note:
            - Creates temporary directories that are cleaned up on stop
            - Uses default ports (8080 for REST API, 8081 for faucet)
            - Only one testnet should be running per machine
            - Testnet state is ephemeral and lost when stopped
        """
        AptosCLIWrapper.assert_cli_exists()
        return AptosInstance.start()

    @staticmethod
    def test_package(package_dir: str, named_addresses: Dict[str, AccountAddress]):
        """Run Move unit tests for a package using the Aptos CLI.

        This method executes all unit tests defined in the Move package,
        providing comprehensive test coverage and validation. Tests run in
        an isolated environment with proper address resolution.

        Args:
            package_dir: Path to the directory containing the Move package
                (must contain a Move.toml file).
            named_addresses: Dictionary mapping named address identifiers
                to their resolved AccountAddress values.

        Raises:
            MissingCLIError: If the Aptos CLI is not found or accessible.
            CLIError: If any tests fail or the test process encounters errors.

        Examples:
            Run basic tests::

                AptosCLIWrapper.test_package(
                    package_dir="./my-move-package",
                    named_addresses={}
                )

            Run tests with named addresses::

                from aptos_sdk.account_address import AccountAddress

                test_addresses = {
                    "test_admin": AccountAddress.from_str("***cafe"),
                    "test_user": AccountAddress.from_str("***beef")
                }

                AptosCLIWrapper.test_package(
                    package_dir="./my-package",
                    named_addresses=test_addresses
                )

        Test Features:
            - Isolated test execution environment
            - Access to Move testing framework
            - Proper address and resource simulation
            - Detailed test result reporting
            - Coverage analysis capabilities

        Test Structure:
            Tests should be defined using the Move testing framework::

                #[test]
                public fun test_basic_functionality() {
                    // Test logic here
                }

                #[test(admin = @***1, user = @***2)]
                public fun test_with_addresses(admin: &signer, user: &signer) {
                    // Test with specific signers
                }

        Note:
            - Tests run in a simulated blockchain environment
            - Named addresses are resolved during test execution
            - Failed tests will cause the method to raise CLIError
            - Test output includes detailed failure information
        """
        AptosCLIWrapper.assert_cli_exists()
        args = [
            DEFAULT_BINARY,
            "move",
            "test",
            "--package-dir",
            package_dir,
        ]
        args.extend(AptosCLIWrapper.prepare_named_addresses(named_addresses))

        process_output = subprocess.run(args, capture_output=True)
        if process_output.returncode != 0:
            raise CLIError(args, process_output.stdout, process_output.stderr)

    @staticmethod
    def assert_cli_exists():
        """Assert that the Aptos CLI is available and accessible.

        Raises:
            MissingCLIError: If the Aptos CLI cannot be found in the system PATH
                or at the location specified by APTOS_CLI_PATH environment variable.

        Example:
            >>> AptosCLIWrapper.assert_cli_exists()
            # Raises MissingCLIError if CLI not found

        Note:
            This method is called internally by other CLI operations to ensure
            the CLI is available before attempting to execute commands.
        """
        if not AptosCLIWrapper.does_cli_exist():
            raise MissingCLIError()

    @staticmethod
    def does_cli_exist():
        """Check if the Aptos CLI is available and accessible.

        This method verifies that the Aptos CLI binary can be found and executed
        from the current environment. It checks both the system PATH and any
        custom path specified via the APTOS_CLI_PATH environment variable.

        Returns:
            True if the CLI is available, False otherwise.

        Examples:
            Check CLI availability::

                if AptosCLIWrapper.does_cli_exist():
                    print("Aptos CLI is ready to use")
                    AptosCLIWrapper.compile_package("./package", {})
                else:
                    print("Please install the Aptos CLI")
                    print("Visit: https://aptos.dev/tools/aptos-cli/")

            Conditional operations::

                def safe_compile(package_dir, named_addresses):
                    if not AptosCLIWrapper.does_cli_exist():
                        raise RuntimeError("Aptos CLI not available")
                    return AptosCLIWrapper.compile_package(package_dir, named_addresses)

        Environment Variables:
            APTOS_CLI_PATH: Custom path to the Aptos CLI binary if not in PATH.

        Note:
            This method uses shutil.which() to locate the CLI binary, which
            respects the system PATH and executable permissions.
        """
        return shutil.which(DEFAULT_BINARY) is not None


class MissingCLIError(Exception):
    """Exception raised when the Aptos CLI cannot be found or accessed.

    This error indicates that the Aptos CLI binary is not available in the
    system PATH or at the location specified by the APTOS_CLI_PATH environment
    variable. This prevents any CLI operations from being executed.

    Common Causes:
    - Aptos CLI is not installed
    - CLI binary is not in system PATH
    - APTOS_CLI_PATH points to incorrect location
    - Insufficient permissions to execute the CLI
    - CLI binary is corrupted or incompatible

    Resolution:
    1. Install the Aptos CLI from https://aptos.dev/tools/aptos-cli/
    2. Ensure the binary is in your system PATH
    3. Set APTOS_CLI_PATH environment variable if using custom location
    4. Verify executable permissions on the CLI binary

    Examples:
        Handling the error::

            from aptos_sdk.aptos_cli_wrapper import AptosCLIWrapper, MissingCLIError

            try:
                AptosCLIWrapper.compile_package("./package", {})
            except MissingCLIError as e:
                print(f"CLI Error: {e}")
                print("Please install the Aptos CLI")

        Pre-emptive checking::

            if not AptosCLIWrapper.does_cli_exist():
                raise MissingCLIError()

            # Safe to use CLI operations
            AptosCLIWrapper.compile_package("./package", {})

    Attributes:
        message: Detailed error message indicating the expected CLI path.
    """

    def __init__(self):
        """Initialize MissingCLIError with information about the expected CLI path."""
        super().__init__(
            f"The CLI was not found in the expected path, {DEFAULT_BINARY}"
        )


class CLIError(Exception):
    """Exception raised when an Aptos CLI command execution fails.

    This error captures the details of a failed CLI operation, including the
    command that was executed, its output, and any error messages. It provides
    comprehensive information for debugging CLI integration issues.

    Common Causes:
    - Compilation errors in Move code
    - Missing dependencies or configuration
    - Invalid command parameters
    - Network issues during dependency resolution
    - File system permission problems
    - Invalid Move.toml configuration
    - Conflicting named addresses

    Examples:
        Handling compilation errors::

            from aptos_sdk.aptos_cli_wrapper import AptosCLIWrapper, CLIError

            try:
                AptosCLIWrapper.compile_package("./faulty-package", {})
            except CLIError as e:
                print(f"Compilation failed: {e}")
                # Error includes command, output, and stderr for debugging

        Handling test failures::

            try:
                AptosCLIWrapper.test_package("./package-with-failing-tests", {})
            except CLIError as e:
                print("Tests failed with details:")
                print(e)
                # Includes test failure details and error output

    Attributes:
        command: List of command arguments that were executed.
        output: Standard output from the failed command.
        error: Standard error output from the failed command.
        message: Formatted error message with command details.
    """

    def __init__(self, command, output, error):
        """Initialize CLIError with command execution details.

        Args:
            command: List of command arguments that were executed.
            output: Standard output bytes from the command.
            error: Standard error bytes from the command.
        """
        self.command = command
        self.output = output
        self.error = error

        super().__init__(
            f"The CLI operation failed:\n\tCommand: {' '.join(command)}\n\tOutput: {output}\n\tError: {error}"
        )


class AptosInstance:
    """Manages a local Aptos testnet instance for development and testing.

    This class represents a complete local Aptos testnet running as a subprocess,
    including validator node, faucet service, and REST API endpoints. It provides
    lifecycle management with start, stop, and health monitoring capabilities.

    Architecture:
    - Single validator node configuration
    - Built-in faucet for test token distribution
    - REST API endpoint for transaction submission
    - WebAPI for blockchain queries
    - Temporary storage that's cleaned up on stop

    Lifecycle Management:
    - Automatic subprocess management
    - Background output/error capture
    - Health monitoring with REST client
    - Graceful shutdown and cleanup
    - Temporary directory management

    Current Limitations:
    - Fixed port configuration (8080 for REST, 8081 for faucet)
    - Single instance per machine due to port conflicts
    - No persistent storage across restarts
    - Limited configuration customization

    Examples:
        Basic usage::

            # Start local testnet
            testnet = AptosInstance.start()

            try:
                # Wait for testnet to be ready
                is_ready = await testnet.wait_until_operational()

                if is_ready:
                    # Use testnet for operations
                    from aptos_sdk.async_client import RestClient
                    client = RestClient(LOCAL_NODE)
                    chain_id = await client.chain_id()
                    print(f"Testnet ready, chain ID: {chain_id}")
                else:
                    print("Testnet failed to start")
            finally:
                # Always clean up
                testnet.stop()

        Monitoring testnet health::

            testnet = AptosInstance.start()

            # Check if testnet is operational
            if await testnet.is_operational():
                print("Testnet is healthy")
            else:
                print("Testnet is not responding")

            # Check for early termination
            if testnet.is_stopped():
                print("Testnet process has stopped")
                errors = testnet.errors()
                if errors:
                    print(f"Error output: {errors}")

        Context management pattern::

            async def with_local_testnet():
                testnet = AptosInstance.start()
                try:
                    await testnet.wait_until_operational()
                    return testnet
                except Exception:
                    testnet.stop()
                    raise

    Network Configuration:
        - REST API: http://127.0.0.1:8080/v1
        - Faucet API: http://127.0.0.1:8081
        - Chain ID: Dynamically generated for each instance

    Resource Management:
        - Creates temporary directory for blockchain data
        - Spawns subprocess for node execution
        - Background threads for output capture
        - Automatic cleanup on stop() or destruction

    Security Notes:
        - Intended for development and testing only
        - Private keys are generated for convenience, not security
        - No persistent storage or backup mechanisms
        - Local network access only

    Future Improvements:
        - Configurable port assignments for multiple instances
        - Enhanced process monitoring and restart capabilities
        - Configurable blockchain parameters
        - Persistent storage options
    """

    _node_runner: subprocess.Popen
    _temp_dir: tempfile.TemporaryDirectory
    _output: List[str]
    _error: List[str]

    def __del__(self):
        """Destructor that ensures testnet cleanup on object destruction.

        This method is called automatically when the AptosInstance object
        is garbage collected, ensuring that the testnet process is properly
        terminated and resources are cleaned up.

        Note:
            While this provides a safety net, it's better to explicitly
            call stop() to ensure timely resource cleanup.
        """
        self.stop()

    def __init__(
        self, node_runner: subprocess.Popen, temp_dir: tempfile.TemporaryDirectory
    ):
        """Initialize AptosInstance with subprocess and temporary directory.

        This constructor sets up the testnet instance with process management
        and output capture. It starts background threads to continuously
        capture stdout and stderr from the node process.

        Args:
            node_runner: Subprocess running the Aptos node.
            temp_dir: Temporary directory for blockchain data storage.

        Note:
            This constructor is typically called by the start() class method
            rather than directly by user code.
        """
        self._node_runner = node_runner
        self._temp_dir = temp_dir

        self._output = []
        self._error = []

        def queue_lines(pipe, target):
            """Background thread function to capture process output.

            Args:
                pipe: Process pipe (stdout or stderr).
                target: List to store captured lines.
            """
            for line in iter(pipe.readline, b""):
                if line == "":
                    continue
                target.append(line)
            pipe.close()

        # Start background thread for stderr capture
        err_thread = threading.Thread(
            target=queue_lines, args=(node_runner.stderr, self._error)
        )
        err_thread.daemon = True
        err_thread.start()

        # Start background thread for stdout capture
        out_thread = threading.Thread(
            target=queue_lines, args=(node_runner.stdout, self._output)
        )
        out_thread.daemon = True
        out_thread.start()

    @staticmethod
    def start() -> AptosInstance:
        """Start a new local Aptos testnet instance.

        This factory method creates and starts a complete local Aptos testnet
        with validator node, faucet service, and REST API. The testnet runs
        in an isolated temporary directory and is ready for development use.

        Returns:
            AptosInstance object representing the running testnet.

        Raises:
            subprocess.SubprocessError: If the testnet process fails to start.
            OSError: If temporary directory creation fails.

        CLI Arguments Used:
            - run-local-testnet: Main command to start local testnet
            - --test-dir: Directory for blockchain data storage
            - --with-faucet: Enable built-in faucet service
            - --force-restart: Clean start, removing existing data
            - --assume-yes: Skip interactive confirmations

        Examples:
            Basic startup::

                testnet = AptosInstance.start()

                # Wait for testnet to become ready
                if await testnet.wait_until_operational():
                    print("Testnet is ready for use!")

                # Clean up when done
                testnet.stop()

            Error handling::

                try:
                    testnet = AptosInstance.start()
                    await testnet.wait_until_operational()
                except subprocess.SubprocessError as e:
                    print(f"Failed to start testnet: {e}")
                except OSError as e:
                    print(f"Filesystem error: {e}")

        Network Endpoints:
            After successful startup, the testnet provides:
            - REST API: http://127.0.0.1:8080/v1
            - Faucet: http://127.0.0.1:8081

        Resource Allocation:
            - Temporary directory for blockchain storage
            - Subprocess for node execution
            - Background threads for output capture
            - Network ports (8080, 8081)

        Note:
            The testnet starts immediately but may take a few seconds to become
            fully operational. Use wait_until_operational() to ensure readiness
            before performing operations.
        """
        temp_dir = tempfile.TemporaryDirectory()
        args = [
            DEFAULT_BINARY,
            "node",
            "run-local-testnet",
            "--test-dir",
            str(temp_dir.name),
            "--with-faucet",
            "--force-restart",
            "--assume-yes",
        ]
        node_runner = subprocess.Popen(
            args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        return AptosInstance(node_runner, temp_dir)

    def stop(self):
        """Stop the local testnet and clean up all associated resources.

        This method gracefully terminates the testnet process, waits for it
        to exit, and cleans up the temporary directory. It ensures complete
        resource cleanup and prevents resource leaks.

        Process:
        1. Send termination signal to the node process
        2. Wait for process to exit cleanly
        3. Clean up temporary directory and files
        4. Release any held resources

        Examples:
            Basic cleanup::

                testnet = AptosInstance.start()
                # ... use testnet ...
                testnet.stop()  # Always clean up

            Exception-safe cleanup::

                testnet = AptosInstance.start()
                try:
                    # Testnet operations
                    await testnet.wait_until_operational()
                    # ... perform tests ...
                finally:
                    testnet.stop()  # Ensure cleanup even if tests fail

        Note:
            - This method is idempotent - safe to call multiple times
            - Automatically called by destructor as safety net
            - Blocks until process termination is complete
            - All blockchain data is permanently lost after cleanup

        Warning:
            After calling stop(), the AptosInstance should not be used for
            any further operations. Create a new instance if needed.
        """
        if hasattr(self, "_node_runner") and self._node_runner:
            self._node_runner.terminate()
            self._node_runner.wait()
        if hasattr(self, "_temp_dir") and self._temp_dir:
            self._temp_dir.cleanup()

    def errors(self) -> List[str]:
        """Get error output lines from the testnet process.

        Returns:
            List of error messages from the node's stderr stream.

        Examples:
            Checking for errors::

                testnet = AptosInstance.start()

                if testnet.is_stopped():
                    errors = testnet.errors()
                    if errors:
                        print("Testnet failed with errors:")
                        for error in errors:
                            print(f"  {error.strip()}")

            Debugging startup issues::

                testnet = AptosInstance.start()
                await asyncio.sleep(5)  # Wait a bit

                if not await testnet.is_operational():
                    print("Testnet not ready, checking errors:")
                    for error in testnet.errors():
                        print(error)

        Note:
            - Errors are captured continuously in background thread
            - List grows over time as more errors occur
            - Useful for debugging testnet startup or runtime issues
        """
        return self._error

    def output(self) -> List[str]:
        """Get standard output lines from the testnet process.

        Returns:
            List of output messages from the node's stdout stream.

        Examples:
            Monitoring testnet output::

                testnet = AptosInstance.start()
                await testnet.wait_until_operational()

                # Check what the testnet has logged
                output = testnet.output()
                print("Testnet output:")
                for line in output[-10:]:  # Last 10 lines
                    print(f"  {line.strip()}")

            Debugging connectivity::

                testnet = AptosInstance.start()

                # Look for specific startup messages
                output = testnet.output()
                if any("REST API" in line for line in output):
                    print("REST API is ready")

        Note:
            - Output is captured continuously in background thread
            - Includes all informational and debug messages
            - Useful for understanding testnet behavior and status
        """
        return self._output

    async def wait_until_operational(self) -> bool:
        """Wait for the testnet to become fully operational.

        This method polls the testnet's health endpoints until either the
        testnet becomes operational or the maximum wait time is exceeded.
        It checks both the REST API and faucet service for readiness.

        Returns:
            True if testnet becomes operational within timeout, False otherwise.

        Timeout:
            Maximum wait time is controlled by MAXIMUM_WAIT_TIME_SEC (30 seconds).

        Examples:
            Basic startup waiting::

                testnet = AptosInstance.start()

                if await testnet.wait_until_operational():
                    print("Testnet is ready for use!")
                    # Safe to make API calls
                else:
                    print("Testnet failed to start within timeout")
                    testnet.stop()

            With custom timeout handling::

                testnet = AptosInstance.start()

                start_time = time.time()
                is_ready = await testnet.wait_until_operational()
                elapsed = time.time() - start_time

                if is_ready:
                    print(f"Testnet ready in {elapsed:.2f} seconds")
                else:
                    print(f"Testnet timeout after {elapsed:.2f} seconds")
                    errors = testnet.errors()
                    if errors:
                        print("Error output:", errors[-5:])  # Last 5 errors

        Health Checks:
            - REST API chain_id() call must succeed
            - Faucet healthy() check must return True
            - Process must still be running

        Polling Behavior:
            - Checks health every 100ms (0.1 seconds)
            - Exits early if testnet becomes operational
            - Exits early if testnet process stops
            - Times out after MAXIMUM_WAIT_TIME_SEC seconds

        Note:
            This method is essential for ensuring testnet readiness before
            performing operations. Using the testnet before it's operational
            will result in connection errors.
        """
        operational = await self.is_operational()
        start = time.time()
        last = start

        while (
            not self.is_stopped()
            and not operational
            and start + MAXIMUM_WAIT_TIME_SEC > last
        ):
            await asyncio.sleep(0.1)
            operational = await self.is_operational()
            last = time.time()
        return not self.is_stopped()

    async def is_operational(self) -> bool:
        """Check if the testnet is currently operational.

        This method performs health checks on both the REST API and faucet
        service to determine if the testnet is ready to handle requests.

        Returns:
            True if both REST API and faucet are responding correctly.

        Health Checks:
        1. REST API chain_id() call - validates core node functionality
        2. Faucet healthy() check - validates faucet service availability

        Examples:
            Simple health check::

                testnet = AptosInstance.start()
                await asyncio.sleep(2)  # Give it time to start

                if await testnet.is_operational():
                    print("Testnet is healthy")
                else:
                    print("Testnet is not responding")

            Continuous monitoring::

                testnet = AptosInstance.start()

                for i in range(10):
                    if await testnet.is_operational():
                        print(f"Healthy at attempt {i+1}")
                        break
                    await asyncio.sleep(1)
                else:
                    print("Testnet failed to become healthy")

        Error Handling:
            - Any exception during health checks returns False
            - Network timeouts are treated as non-operational
            - HTTP errors indicate non-operational state
            - Client connections are properly cleaned up

        Note:
            This method creates temporary client connections that are
            automatically closed after the health check completes.
        """
        rest_client = RestClient(LOCAL_NODE)
        faucet_client = FaucetClient(LOCAL_FAUCET, rest_client)

        try:
            # Test REST API functionality
            await rest_client.chain_id()
            # Test faucet service health
            return await faucet_client.healthy()
        except Exception:
            # Any exception means not operational
            return False
        finally:
            # Always clean up client connection
            await rest_client.close()

    def is_stopped(self) -> bool:
        """Check if the testnet process has stopped running.

        Returns:
            True if the node process has terminated, False if still running.

        Examples:
            Check for early termination::

                testnet = AptosInstance.start()
                await asyncio.sleep(1)

                if testnet.is_stopped():
                    print("Testnet stopped unexpectedly")
                    errors = testnet.errors()
                    if errors:
                        print("Last error:", errors[-1])

            Monitor during operations::

                testnet = AptosInstance.start()
                await testnet.wait_until_operational()

                # Perform operations...

                if testnet.is_stopped():
                    print("Testnet crashed during operation")
                    # Handle the failure

        Return Code:
            - None: Process is still running
            - 0: Process exited successfully
            - Non-zero: Process exited with error

        Note:
            This method checks the subprocess return code without blocking.
            It's useful for detecting unexpected termination during operations.
        """
        return self._node_runner.returncode is not None
